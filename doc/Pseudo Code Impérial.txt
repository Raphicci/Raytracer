// CODE EN BAS


BOITES :
Découper la scène en boites, repérer quels objets sont dans quelles boites et chercher d'abord les intersections avec les boites (si bien fait il y aura bcp moins
d'intersection, et le calcul d'intersection avec une boite est peu coûteux en ressources). Imo commencer par créer une grosse boite qui englobe tout , la découper
en 2 / 4 / 8 boites, elles-même redécoupées en 2 / 4 / 8 boites. (2, 4 ou 8 ? S'il y a peu d'objets, réduire le nombre de boites ? La grosse boite est - t - elle utile ?
La vie a-t-elle un sens ?)
Plein plein de manières de découper la scène en boites... Pour commencer, ne faire que la boite globale (quitte à la supprimer plus tard si ça fout plus la merde qu'autre chose)


GRILLE :
On bosse case par case (genre 50x50). On calcule une partie des points. Pour ces points là on save quelle(s) box on croise (par ordre de rencontre,
ce sera important pour la suite).
Ensuite pour les autres pixels on avance box par box tant qu'on a pas trouvé d'obj, et dès qu'on en a trouvé un 
on prend le plus proche dans la box.
// Globalement je pense que l'idée boite / grille est une bonne idée mais need y réfléchir un max avant de l'implémenter


REFLEXION: (tout pareil pour transparence)
Ajouter aux objets qui ont une reflexion une constante (genre glossy) qui plus elle sera proche de 1 plus la proportion de rayons random sera grande.
Un miroir serait à 0, une vitre à 1 (fin a tester mais ça me parait logique)
CALCULER AVEC QUEL(S) OBJET IL Y A LINTERSECTION POUR LES 4(8?) VECTEURS LES PLUS EXCENTRES, ET NE CHERCHER L'INTER QU'AVEC CEs OBJETs
Calculer avec quel(s) objet(s) il y a intersection pour les 4(8 ?) vecteurs les plus excentrés, et ne chercher l'inter qu'avec ces objets pour le reste des rayons
Créer classe ReflectHandler ? Il contiendrait plein d'infos servant à ne pas avoir à recalculer des trucs pdt la ref


MOTION BLUR :
Donner aux objets une vitesse en VALUE/FRAME pour chaque axe
Quand on rencontre un objet, s'il a une vitesse, on choppe la couleur puis on recalcule le pixel mais pour l'objet dans sa position une frame 
plus tard, et on fait la diff des deux (étaler sur plus de positions pour une meilleur image ?).
Problème : ça marche pas pour la position "future" de l'objet, du coup mettre l'objet dans une boite qui englobe toutes les positions au cours du temps,
Imo ça devrait marcher mais pour etre joli il va falloir un max de calculs :(



EDITION DE SCENE :
Notamment pour mettre en place une vidéo, pouvoir éditer la scène en live live en calculant que grossièrement le rendu(une lumière, pas d'ombre, pas de 
reflexion/transp) voir remplacer les objets par des cubes, ça pourrait être cool



LUMIERE :
Ne plus diviser par le nombre de lumières, remplacer par un prevent overflow après tous les calculs. Gérer l'intensité des lumières



OMBRES :
Donc pour les ombres floues on envoie plusieurs rayons, un peu random, au lieu d'un seul. Comment opti ? Checker les 4(8?) rayons excentré,
et s'ils sont tous à l'ombre / pas à l'ombre, pas besoin de calc le reste. Sinon, save quel(s) objet(s) bloque(nt) la lumière et ne refaire les tests que sur
ceux là.
Pareil, créer une classe ShadowHandler ?


RENDU CARTOON :
Marquer contours avec filtre sobel. Pour la couleur de l'objet, calculer le cos puis attribuer une couleur selon la range dans laquelle est le cos (et par
rapport à la couleur de l'objet) (par contre pas sur que ça passe bien avec lumieres colorées, mais pas compliqué à gérer si besoin);



//A partir d'une direction et d'un angle, retourne un vecteur random qui va a peu près vers la direction
//Utile pour ombres floues, reflexion/transparence plus réaliste
Vector	getRandomVecFromDir(Vector *dir, float angle)
{
	Vector	vec;
	float	half = angle / 2;

	vec = *dir; //copie

	vec.rotate(RAND % angle - half, RAND % angle - half, RAND % angle - half)

	return (vec);
}





//L'idée c'est de couper la scène en boites, de précalculer si un obj est dans la boite (#moins de calculs)
Box	createBigBox(liste d'objets)
{
	Parcourir listeObjet;
	récupérer plus petit x / y / z, plus grand x / y / z    // prendre en compte la taille de l'obj

	box.corner1 = petit x / y / z // coin en bas à gauche
	box.corner2 = grand x / y / z // coin au fond en haut à droite
	return (box);
}
ListBox	createBoxesInsideBox(Box bigBox) // AKA BoxCeption
{
	listBox liste[4];
	lenght = abs (bigBox.corner1.x - bigBox.corner2.x);
	width = abs (bigBox.corner1.y - bigBox.corner2.y);

	liste[0].corner1.x = ;
	liste[0].corner1.y = ;
	liste[0].corner1.z = ;
	liste[0].corner2.x = ;
	liste[0].corner2.y = ;
	liste[0].corner2.z = ;
}
Bool	objInsideBox(Object obj, Box box)
{
	damn c'est compliqué ça.
	imo le plus simple c'est de mettre des box pour tout, et après c'est easy
	genre une sphere sa boite c'est centre -/+ rayon (en x y z) pour le coin en haut et en bas.
	après il suffit de determiner si un des 4 coins est dans la box (xmin<=x<=xmax && ymin<=y<=ymax && zmin<=z<=zmax)
	Vu qu'on a la boite, est-ce que tester l'intersection avec la boite avant celle avec la sphere vaut le coup ?
}
double	inter_box() //cf inter_box.c
{
	précalculer l'inverse du vecteur directeur, au cas ou il y ait (et il y aura) plusieurs boites.
	calculer tmax, faire le test if tmax < 0, et tmin après

	globablement, voir s'il n'y a pas plus efficient
}
// SI UNE BOITE NE CONTIENT PAS D'OBJET, LA SUPPRIMER DE LA LISTE





//filtre de sobel pour cel-shading
int[][] sobel3x3(int[][] input, int W, int H) {
	int[][] output = new int[W][H];
	for (int y = 1; y < H - 1; y++) {
		for (int x = 1; x < W - 1; x++) {
			int gx = ((input[x+1][y-1]-input[x-1][y-1]) + 2 * (input[x+1][y]-input[x-1][y]) + (input[x+1][y+1]-input[x-1][y+1]))/4;
			int gy = ((input[x-1][y+1]-input[x-1][y-1]) + 2 * (input[x][y+1]-input[x][y-1]) + (input[x+1][y+1]-input[x+1][y-1]))/4;
			int gn = (int) Math.sqrt(gx*gx + gy*gy);
			output[x][y] = gn;
		}
	}
	return output;
}
int  cartoonColor(cos, objectColor) // le cos doit etre le total de tous les cos s'il y a plusieurs lumières qui eclairent lobj, chaque cos étant multiplié par l'intensité de sa lumiere
{
	int nombreCouches = 3;
	float inv = 1 / nombreCouches;
	int i = 1;

	while (i < nombreCouches)
	{	
		if (cos <= i * inv)
			return (objectColor * (i * inv))
	i++;
	}
	return (objectColor);
// à tester mais ça devrait marcher
}