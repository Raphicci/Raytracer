// premières idées que je balance comme ça, sans pression


Bon je persiste à penser qu'il faut une classe rayon, on ne peut pas se passer du t_ray_data du rt


Sinon, pour les classes:




class Object:			toutes les infos pour 1 objet (hérité par chaque objet)
		Attributes:
				-Point pos (je suppose que la classe Point existe)
				-Vector rot (vector pour la rot ?)
				-Limites lim (go créer une classe limite)
				-t_cons constantes (structures pour les constantes ? je vois pas l'interet d'une classe)
				-Color col (go créer une classe color)
				-Texture text (go créer une classe texture)
		Méthodes :
				-Tous les 7h et Guetteurs
				-FindIntersection(Vector v)  (à override) return un point


class Rayon:
		Attributes :	
				-Vector dir
				-Point intersection
				-Vector normale
				-*Object obj (pointeur sur obj rencontré)
				-double k (distance à l'obj trouvé)
				-bool outside (bool pour les limites)
				-Float ombre (set à 0, modifié à chaque ombre, on arrete de caculer dès qu'il est >= 1)
		Méthodes :
				-7h / Guetteurs
				-???


class Vector : //La classe Vector3 de la SMFL ne contient que des surcharges d'opérateur, heriter de cette classe pour y rajouter de méthodes ?
		Attributes :
				-x
				-y   // hérité de Vector3
				-z
				-isNormalized
		Méthodes :
				-7h / Guetteurs
				-Constructeur : soit () -> 0, 0, 0  soit (x, y, z)  soit (Vector A, Vector B)
				-Void Normalize();
				-Bool isNormalized();
				-Void Reverse();
				-Double Scalaire(vector vec); //question : fonction scalaire à part ou en méthode ?
				-Vec ProduitVec(vector vec); // même interrogation qu'au dessus
				-Void RotateX(double ang);
				-Void RotateY(double ang);
				-Void RotateZ(double ang);
				-Void Rotate(double angX, double angY, double angZ);

class Point : //Pareil, hériter de Vector3 ?
		Attributes :
				-x
				-y
				-z
		Méthodes :
				-7h / Guetteurs
				-Void Translate(double x, double y, double z); // séparer en trois méthodes pour x, y, z ?
				-Void RotateAroundOrigin(double x, double y, double z);
				-Void RotateAroundPoint(double x, double y, double z, Point p);

class Color : //herite de Color sfml
		Attributes :
				-int r
				-int g
				-int b
				-int color (utile ?)
		Méthodes :
				-Void Mix(Color c)   ou (List<Color> c)
				-Void PreventOverflow(); //si une composante est > 255, la remettre à 255 et diminuer les autres du même rapport d'échelle //Pas besoin, déja géré par le '*' de la sfml






Class Data : Toutes les infos (pas de meéthodes)





Question : est ce que les classes sans méthodes ont un interet ? (encapsulation ?)



idée, peut etre completement conne, save tous les rayons dans un fichier, qu'on pourrait réimporter à partir de l'interface, et faire des trucs avec
